// USE ONLY THIS FILE FOR PRODUCTION
// This file is part of the DoTheWorld project.
// Do not edit this file, it is automatically generated.
// See the README.md file for more information.



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>



#ifdef __linux__
  #include <dirent.h>
  #include <unistd.h>
#elif _WIN32
  #include <windows.h>
  #include <tchar.h>
  #include <wchar.h>
  #include <locale.h>
  #include <direct.h>
#endif
#define DTW_FILE_TYPE 1
#define DTW_FOLDER_TYPE 2
#define DTW_ALL_TYPE 3
#define NOT_FOUND -1

struct DtwStringArray {
  int size;         

  char **strings;       
  void (*set_value)(struct DtwStringArray *self,int index,const char *value);
  void (*add_string)(struct DtwStringArray *self,const char *string);
  void (*merge_string_array)(struct DtwStringArray *self, struct DtwStringArray *other);
  void (*represent)(struct DtwStringArray *self);
  void (*delete_string_array)(struct DtwStringArray *self);
}; // End the structure with a semicolon

void private_dtw_add_string(struct DtwStringArray *self,const char *string);
void private_dtw_merge_string_array(struct DtwStringArray *self, struct DtwStringArray *other);
void private_dtw_represent_string_array(struct DtwStringArray *self);
void private_dtw_delete_string_array(struct DtwStringArray *self);
void private_dtw_set_value(struct DtwStringArray *self,int index,const char *value);

struct DtwStringArray * dtw_constructor_string_array();

char * dtw_generate_sha_from_file(const char *path);
char * dtw_generate_sha_from_string(const char *string);
long int dtw_get_file_last_motification_in_unix(const char *path);
char * dtw_convert_unix_time_to_string(long int unix_time);
char * dtw_get_file_last_motification_in_string(const char *path);
bool dtw_starts_with(const char *string, const char *prefix);
bool dtw_ends_with(const char *string, const char *suffix);

char *private_dtw_replace_string_once(const char *target, const char *old_element, const char *new_element);

char* dtw_replace_string(const char *target, const char *old_element, const char *new_element);


char *dtw_change_beginning_of_string(const char *target,int start_element_to_remove_size, const char *new_element);

void private_dtw_add_end_bar_to_dirs_string_array(struct DtwStringArray * dirs);

#ifdef __linux__
#define dtw_create_dir(path) mkdir(path,0777)
#elif _WIN32
#define dtw_create_dir(path) _mkdir(path)
#endif

void dtw_create_dir_recursively(const char *path);

void dtw_remove_any(const char* path);


char *dtw_load_any_content(const char * path,int *size,bool *is_binary);
char *dtw_load_string_file_content(const char * path);


char *dtw_load_binary_content(const char * path,int *size);


bool dtw_write_any_content(const char *path,const char *content,int size);
bool dtw_write_string_file_content(const char *path,char *content);
int dtw_entity_type(const char *path);

#ifdef __cplusplus
    bool dtw_copy_any(const char* src_path,const  char* dest_path,bool merge=false);
#else
    bool dtw_copy_any(const char* src_path,const  char* dest_path,bool merge);
#endif 

void dtw_move_any(char* src_path, char* dest_path,bool merge) ;


struct DtwStringArray * dtw_list_files(char *path, bool concat_path);
struct DtwStringArray * dtw_list_dirs(char *path, bool concat_path, bool add_end_bar_to_dir);

struct DtwStringArray *  dtw_list_all(char *path,  bool concat_path, bool add_end_bar_to_dir);


#ifdef __linux__

bool private_dtw_verify_if_add(const int expected_type, int d_type);
bool private_dtw_verify_if_skip(struct dirent *entry);
#ifdef __cplusplus
struct DtwStringArray * dtw_list_basic(
        const char *path,
        int expected_type,
        bool concat_path=false,
        bool add_end_bar_to_dir=true);
#else 
struct DtwStringArray * dtw_list_basic(const char *path,int expected_type,bool concat_path,bool add_end_bar_to_dir);
#endif 


#endif

#ifdef _WIN32


bool private_dtw_verify_if_add(const int expected_type, WIN32_FIND_DATAA entry)
 
#endif

#ifdef __cplusplus
struct DtwStringArray * dtw_list_dirs_recursively(const char *path,bool add_end_bar_to_dir=true);
#else 
struct DtwStringArray * dtw_list_dirs_recursively(const char *path,bool add_end_bar_to_dir);
#endif
  

struct DtwStringArray *  dtw_list_files_recursively(const char *path);

#ifdef __cplusplus
struct DtwStringArray * dtw_list_all_recursively(const char *path,bool add_end_bar_to_dir=true);
#else 
struct DtwStringArray * dtw_list_all_recursively(const char *path,bool add_end_bar_to_dir);
#endif

struct DtwPath {
    char *first_full_path;
    char *dir;
    char *name;
    char *extension;

    //Getters
    bool  (*changed)(struct DtwPath *self);
    char *(*get_full_name) (struct DtwPath *self);
    char *(*get_name) (struct DtwPath *self);
    char *(*get_extension) (struct DtwPath *self);

    char *(*get_full_path) (struct DtwPath *self);
    char *(*get_dir) (struct DtwPath *self);

    
    //Setters
    void (*set_extension) (struct DtwPath *self, const char *extension);
    void (*set_name) (struct DtwPath *self, const char *name);
    void (*set_dir) (struct DtwPath *self, const char *path);
    void (*set_full_name) (struct DtwPath *self, const char *full_name);
    void (*set_full_path) (struct DtwPath *self, const char *full_path);
    void (*represent)(struct DtwPath *self);
    void (*delete_path) (struct DtwPath *self);


};
bool  private_dtw_path_changed(struct DtwPath *self);
char *private_dtw_get_full_name(struct DtwPath *self);
char *private_dtw_get_name(struct DtwPath *self);
char *private_dtw_get_extension(struct DtwPath *self);
char *private_dtw_get_full_path(struct DtwPath *self);
char *private_dtw_get_dir(struct DtwPath *self);

void private_dtw_set_extension(struct DtwPath *self, const char *extension);
void private_dtw_set_name(struct DtwPath * self, const char * name);
void private_dtw_set_dir(struct DtwPath *self, const char *path);

void private_dtw_set_full_name(struct DtwPath * self, const char * full_name);
void private_dtw_set_full_path(struct DtwPath *self, const char *ful_path);

void private_dtw_represent_path(struct DtwPath *self);
void private_dtw_destructor_path(struct DtwPath *self);


#ifndef SHA_256_H
#define SHA_256_H

#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * @brief Size of the SHA-256 sum. This times eight is 256 bits.
 */
#define SIZE_OF_SHA_256_HASH 32

/*
 * @brief Size of the chunks used for the calculations.
 *
 * @note This should mostly be ignored by the user, although when using the streaming API, it has an impact for
 * performance. Add chunks whose size is a multiple of this, and you will avoid a lot of superfluous copying in RAM!
 */
#define SIZE_OF_SHA_256_CHUNK 64

/*
 * @brief The opaque SHA-256 type, that should be instantiated when using the streaming API.
 *
 * @note Although the details are exposed here, in order to make instantiation easy, you should refrain from directly
 * accessing the fields, as they may change in the future.
 */
struct Sha_256 {
	uint8_t *hash;
	uint8_t chunk[SIZE_OF_SHA_256_CHUNK];
	uint8_t *chunk_pos;
	size_t space_left;
	size_t total_len;
	uint32_t h[8];
};

/*
 * @brief The simple SHA-256 calculation function.
 * @param hash Hash array, where the result is delivered.
 * @param input Pointer to the data the hash shall be calculated on.
 * @param len Length of the input data, in byte.
 *
 * @note If all of the data you are calculating the hash value on is available in a contiguous buffer in memory, this is
 * the function you should use.
 *
 * @note If either of the passed pointers is NULL, the results are unpredictable.
 */
void calc_sha_256(uint8_t hash[SIZE_OF_SHA_256_HASH], const void *input, size_t len);

/*
 * @brief Initialize a SHA-256 streaming calculation.
 * @param sha_256 A pointer to a SHA-256 structure.
 * @param hash Hash array, where the result will be delivered.
 *
 * @note If all of the data you are calculating the hash value on is not available in a contiguous buffer in memory, this is
 * where you should start. Instantiate a SHA-256 structure, for instance by simply declaring it locally, make your hash
 * buffer available, and invoke this function. Once a SHA-256 hash has been calculated (see further below) a SHA-256
 * structure can be initialized again for the next calculation.
 *
 * @note If either of the passed pointers is NULL, the results are unpredictable.
 */

char * calc_sha_256_returning_string(const void *input, size_t len);
/*
	@param input: the string to be hashed
	@param len: the length of the string
	@return: the hash of the string
	@note: if the input string is NULL, the results are unpredictable
*/

void calc_sha_256_from_string(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *input);
/*
	@param hash: the hash array, where the result is delivered
	@param input: the string to be hashed
	@note: if the input string is NULL, the results are unpredictable
*/

int calc_sha_256_from_file(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *filename);
/*
	@param hash: the hash array, where the result is delivered
	@param filename: the name of the file to be hashed
	@return: 0 if the file was hashed successfully, -1 otherwise
*/

char * calc_sha_256_from_file_returning_string(const char *filename);
/*
	@param filename: the name of the file to be hashed
	@return: the hash of the file
	@note: if the filename is NULL, the return value is NULL
*/

void sha_256_init(struct Sha_256 *sha_256, uint8_t hash[SIZE_OF_SHA_256_HASH]);

/*
 * @brief Stream more input data for an on-going SHA-256 calculation.
 * @param sha_256 A pointer to a previously initialized SHA-256 structure.
 * @param data Pointer to the data to be added to the calculation.
 * @param len Length of the data to add, in byte.
 *
 * @note This function may be invoked an arbitrary number of times between initialization and closing, but the maximum
 * data length is limited by the SHA-256 algorithm: the total number of bits (i.e. the total number of bytes times
 * eight) must be representable by a 64-bit unsigned integer. While that is not a practical limitation, the results are
 * unpredictable if that limit is exceeded.
 *
 * @note This function may be invoked on empty data (zero length), although that obviously will not add any data.
 *
 * @note If either of the passed pointers is NULL, the results are unpredictable.
 */
void sha_256_write(struct Sha_256 *sha_256, const void *data, size_t len);

/*
 * @brief Conclude a SHA-256 streaming calculation, making the hash value available.
 * @param sha_256 A pointer to a previously initialized SHA-256 structure.
 * @return Pointer to the hash array, where the result is delivered.
 *
 * @note After this function has been invoked, the result is available in the hash buffer that initially was provided. A
 * pointer to the hash value is returned for convenience, but you should feel free to ignore it: it is simply a pointer
 * to the first byte of your initially provided hash array.
 *
 * @note If the passed pointer is NULL, the results are unpredictable.
 *
 * @note Invoking this function for a calculation with no data (the writing function has never been invoked, or it only
 * has been invoked with empty data) is legal. It will calculate the SHA-256 value of the empty string.
 */
uint8_t *sha_256_close(struct Sha_256 *sha_256);



#ifdef __cplusplus
}
#endif

#endif

struct DtwTreePart{
    
    struct DtwPath *path;
    bool content_exist_in_memory;
    long last_modification_time;
    bool content_exist_in_hardware;
    bool ignore;
    bool is_binary;
    char *hawdware_content_sha;
    char *content;

    int content_size;

    char *(*get_content_sha)(struct DtwTreePart *self);
    char *(*last_modification_time_in_string)(struct DtwTreePart *self);
    void (*set_any_content)(struct DtwTreePart *self,const char *content,int content_size,bool is_binary,bool set_last_modification_time);
    void (*set_string_content)(struct DtwTreePart *self,const char *content);
    void (*set_binary_content)(struct DtwTreePart *self,const char *content,int content_size);
    void (*load_content_from_hardware)(struct DtwTreePart *self);
    void (*free_content)(struct DtwTreePart *self);
    void(*represent)(struct DtwTreePart *self);
    bool(*hardware_remove)(struct DtwTreePart *self);
    bool(*hardware_write)(struct DtwTreePart *self);
    void (*delete_tree_part)(struct DtwTreePart *self);
    struct DtwTreePart *(*copy_tree_part)(struct DtwTreePart *self);
};
char *private_dtw_get_content_sha(struct DtwTreePart *self);
char *private_dtw_last_modification_time_in_string(struct DtwTreePart *self);
void private_dtw_set_any_content(struct DtwTreePart *self,const char *content,int content_size,bool is_binary,bool set_last_modification_time);
void private_dtw_set_string_content(struct DtwTreePart *self,const char *content);
void private_dtw_set_binary_content(struct DtwTreePart *self,const char *content,int content_size);
void private_dtw_load_content_from_hardware(struct DtwTreePart *self);
void private_dtw_free_content(struct DtwTreePart *self);
void private_dtw_represent_tree_part(struct DtwTreePart *self);
bool private_dtw_hardware_remove(struct DtwTreePart *self);
bool private_dtw_hardware_write(struct DtwTreePart *self);
void private_dtw_tree_part_destructor(struct DtwTreePart *self);
struct DtwTreePart * private_dtw_copy_tree(struct DtwTreePart *self);



struct DtwTreePart * dtw_tree_part_constructor(const char *full_path,bool load_content);

struct  DtwTree{
    int size;
    struct DtwTreePart **tree_parts;
    void (*add_tree_part_by_copy)(struct DtwTree *self, struct DtwTreePart *tree_part);
    void (*add_tree_part_by_referene)(struct DtwTree *self, struct DtwTreePart *tree_part);
    void(*load_path)(struct DtwTree *self, char *path);
    void (*delete_tree)(struct DtwTree *self);
    void(*represent)(struct DtwTree *self);
};

void private_dtw_add_tree_part_copy(struct DtwTree *self, struct DtwTreePart *tree_part);
void private_dtw_add_tree_part_reference(struct DtwTree *self, struct DtwTreePart *tree_part);
void private_dtw_delete_tree(struct DtwTree *self);
void private_dtw_represent_tree(struct DtwTree *self);


struct  DtwTree * dtw_tree_constructor();



#define TOTAL_LEN_LEN 8

/*
 * Comments from pseudo-code at https://en.wikipedia.org/wiki/SHA-2 are reproduced here.
 * When useful for clarification, portions of the pseudo-code are reproduced here too.
 */

/*
 * @brief Rotate a 32-bit value by a number of bits to the right.
 * @param value The value to be rotated.
 * @param count The number of bits to rotate by.
 * @return The rotated value.
 */
static inline uint32_t right_rot(uint32_t value, unsigned int count)
{
	/*
	 * Defined behaviour in standard C for all count where 0 < count < 32, which is what we need here.
	 */
	return value >> count | value << (32 - count);
}

/*
 * @brief Update a hash value under calculation with a new chunk of data.
 * @param h Pointer to the first hash item, of a total of eight.
 * @param p Pointer to the chunk data, which has a standard length.
 *
 * @note This is the SHA-256 work horse.
 */
static inline void consume_chunk(uint32_t *h, const uint8_t *p)
{
	unsigned i, j;
	uint32_t ah[8];

	/* Initialize working variables to current hash value: */
	for (i = 0; i < 8; i++)
		ah[i] = h[i];

	/*
	 * The w-array is really w[64], but since we only need 16 of them at a time, we save stack by
	 * calculating 16 at a time.
	 *
	 * This optimization was not there initially and the rest of the comments about w[64] are kept in their
	 * initial state.
	 */

	/*
	 * create a 64-entry message schedule array w[0..63] of 32-bit words (The initial values in w[0..63]
	 * don't matter, so many implementations zero them here) copy chunk into first 16 words w[0..15] of the
	 * message schedule array
	 */
	uint32_t w[16];

	/* Compression function main loop: */
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 16; j++) {
			if (i == 0) {
				w[j] =
				    (uint32_t)p[0] << 24 | (uint32_t)p[1] << 16 | (uint32_t)p[2] << 8 | (uint32_t)p[3];
				p += 4;
			} else {
				/* Extend the first 16 words into the remaining 48 words w[16..63] of the
				 * message schedule array: */
				const uint32_t s0 = right_rot(w[(j + 1) & 0xf], 7) ^ right_rot(w[(j + 1) & 0xf], 18) ^
						    (w[(j + 1) & 0xf] >> 3);
				const uint32_t s1 = right_rot(w[(j + 14) & 0xf], 17) ^
						    right_rot(w[(j + 14) & 0xf], 19) ^ (w[(j + 14) & 0xf] >> 10);
				w[j] = w[j] + s0 + w[(j + 9) & 0xf] + s1;
			}
			const uint32_t s1 = right_rot(ah[4], 6) ^ right_rot(ah[4], 11) ^ right_rot(ah[4], 25);
			const uint32_t ch = (ah[4] & ah[5]) ^ (~ah[4] & ah[6]);

			/*
			 * Initialize array of round constants:
			 * (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
			 */
			static const uint32_t k[] = {
			    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4,
			    0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe,
			    0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f,
			    0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
			    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
			    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
			    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
			    0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
			    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
			    0xc67178f2};

			const uint32_t temp1 = ah[7] + s1 + ch + k[i << 4 | j] + w[j];
			const uint32_t s0 = right_rot(ah[0], 2) ^ right_rot(ah[0], 13) ^ right_rot(ah[0], 22);
			const uint32_t maj = (ah[0] & ah[1]) ^ (ah[0] & ah[2]) ^ (ah[1] & ah[2]);
			const uint32_t temp2 = s0 + maj;

			ah[7] = ah[6];
			ah[6] = ah[5];
			ah[5] = ah[4];
			ah[4] = ah[3] + temp1;
			ah[3] = ah[2];
			ah[2] = ah[1];
			ah[1] = ah[0];
			ah[0] = temp1 + temp2;
		}
	}

	/* Add the compressed chunk to the current hash value: */
	for (i = 0; i < 8; i++)
		h[i] += ah[i];
}

/*
 * Public functions. See header file for documentation.
 */

void sha_256_init(struct Sha_256 *sha_256, uint8_t hash[SIZE_OF_SHA_256_HASH])
{
	sha_256->hash = hash;
	sha_256->chunk_pos = sha_256->chunk;
	sha_256->space_left = SIZE_OF_SHA_256_CHUNK;
	sha_256->total_len = 0;
	/*
	 * Initialize hash values (first 32 bits of the fractional parts of the square roots of the first 8 primes
	 * 2..19):
	 */
	sha_256->h[0] = 0x6a09e667;
	sha_256->h[1] = 0xbb67ae85;
	sha_256->h[2] = 0x3c6ef372;
	sha_256->h[3] = 0xa54ff53a;
	sha_256->h[4] = 0x510e527f;
	sha_256->h[5] = 0x9b05688c;
	sha_256->h[6] = 0x1f83d9ab;
	sha_256->h[7] = 0x5be0cd19;
}

void sha_256_write(struct Sha_256 *sha_256, const void *data, size_t len)
{
	sha_256->total_len += len;

	
	const uint8_t *p = (const uint8_t *)data;


	while (len > 0) {
		/*
		 * If the input chunks have sizes that are multiples of the calculation chunk size, no copies are
		 * necessary. We operate directly on the input data instead.
		 */
		if (sha_256->space_left == SIZE_OF_SHA_256_CHUNK && len >= SIZE_OF_SHA_256_CHUNK) {
			consume_chunk(sha_256->h, p);
			len -= SIZE_OF_SHA_256_CHUNK;
			p += SIZE_OF_SHA_256_CHUNK;
			continue;
		}
		/* General case, no particular optimization. */
		const size_t consumed_len = len < sha_256->space_left ? len : sha_256->space_left;
		memcpy(sha_256->chunk_pos, p, consumed_len);
		sha_256->space_left -= consumed_len;
		len -= consumed_len;
		p += consumed_len;
		if (sha_256->space_left == 0) {
			consume_chunk(sha_256->h, sha_256->chunk);
			sha_256->chunk_pos = sha_256->chunk;
			sha_256->space_left = SIZE_OF_SHA_256_CHUNK;
		} else {
			sha_256->chunk_pos += consumed_len;
		}
	}
}

uint8_t *sha_256_close(struct Sha_256 *sha_256)
{
	uint8_t *pos = sha_256->chunk_pos;
	size_t space_left = sha_256->space_left;
	uint32_t *const h = sha_256->h;

	/*
	 * The current chunk cannot be full. Otherwise, it would already have be consumed. I.e. there is space left for
	 * at least one byte. The next step in the calculation is to add a single one-bit to the data.
	 */
	*pos++ = 0x80;
	--space_left;

	/*
	 * Now, the last step is to add the total data length at the end of the last chunk, and zero padding before
	 * that. But we do not necessarily have enough space left. If not, we pad the current chunk with zeroes, and add
	 * an extra chunk at the end.
	 */
	if (space_left < TOTAL_LEN_LEN) {
		memset(pos, 0x00, space_left);
		consume_chunk(h, sha_256->chunk);
		pos = sha_256->chunk;
		space_left = SIZE_OF_SHA_256_CHUNK;
	}
	const size_t left = space_left - TOTAL_LEN_LEN;
	memset(pos, 0x00, left);
	pos += left;
	size_t len = sha_256->total_len;
	pos[7] = (uint8_t)(len << 3);
	len >>= 5;
	int i;
	for (i = 6; i >= 0; --i) {
		pos[i] = (uint8_t)len;
		len >>= 8;
	}
	consume_chunk(h, sha_256->chunk);
	/* Produce the final hash value (big-endian): */
	int j;
	uint8_t *const hash = sha_256->hash;
	for (i = 0, j = 0; i < 8; i++) {
		hash[j++] = (uint8_t)(h[i] >> 24);
		hash[j++] = (uint8_t)(h[i] >> 16);
		hash[j++] = (uint8_t)(h[i] >> 8);
		hash[j++] = (uint8_t)h[i];
	}
	return sha_256->hash;
}

char * sha256_open_file(const char *filename, int *size){
	FILE *file = fopen(filename, "rb");
	if (file == NULL) {
		return NULL;
	}
	fseek(file,0,SEEK_END);
    *size = ftell(file);
    fseek(file,0,SEEK_SET);
    char *content = (char*)malloc(*size +1);
    fread(content,1,*size,file);
	fclose(file);
	return content;
}

//Wrapper functions
void calc_sha_256(uint8_t hash[SIZE_OF_SHA_256_HASH], const void *input, size_t len)
{
	struct Sha_256 sha_256;
	sha_256_init(&sha_256, hash);
	sha_256_write(&sha_256, input, len);
	(void)sha_256_close(&sha_256);
}

char * calc_sha_256_returning_string(const void *input, size_t len)
{
	uint8_t hash[SIZE_OF_SHA_256_HASH];
	calc_sha_256(hash, input, len);
	char *hash_string = (char*)malloc(SIZE_OF_SHA_256_HASH * 2 + 1);
	for (unsigned int i = 0; i < SIZE_OF_SHA_256_HASH; i++) {
		sprintf(hash_string + i * 2, "%02x", hash[i]);
	}
	return hash_string;
}

void  calc_sha_256_from_string(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *input)
{
	calc_sha_256(hash, input, strlen(input));
	
}

char * calc_sha_256_from_string_returning_string(const char *input)
{
	return calc_sha_256_returning_string(input, strlen(input));
}

int calc_sha_256_from_file(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *filename)
{
	int size;
	char *content = sha256_open_file(filename, &size);
	if(content == NULL){
		return -1;
	}
	calc_sha_256(hash, content, size);
	free(content);
	return 0;
}

char * calc_sha_256_from_file_returning_string(const char *filename)
{
	int size;
	char *content = sha256_open_file(filename, &size);
	if(content == NULL){
		return NULL;
	}
	char *hash_string = calc_sha_256_returning_string(content, size);
	free(content);
	return hash_string;

}

char * dtw_generate_sha_from_file(const char *path){
    return calc_sha_256_from_file_returning_string(path);
}


char * dtw_generate_sha_from_string(const char *string){
    return calc_sha_256_from_string_returning_string(string);
}


long int dtw_get_file_last_motification_in_unix(const char *path){
    struct stat attr;
    stat(path, &attr);
    // convert to unix time
    time_t last_modification_in_unix = attr.st_mtime;
    return last_modification_in_unix;
}

char * dtw_convert_unix_time_to_string(long int unix_time){
    struct tm * timeinfo;
    timeinfo = localtime(&unix_time);
    char *time_string = (char *)malloc(100);
    strftime(time_string, 100, "%Y-%m-%d %H:%M:%S", timeinfo);
    return time_string;
}

char * dtw_get_file_last_motification_in_string(const char *path){
    long int last_modification_in_unix = dtw_get_file_last_motification_in_unix(path);
    char *last_modification_in_string = dtw_convert_unix_time_to_string(last_modification_in_unix);
    return last_modification_in_string;
}


bool dtw_starts_with(const char *string, const char *prefix){
    if(strncmp(string, prefix, strlen(prefix)) == 0){
        return true;
    }
    return false;
}

bool dtw_ends_with(const char *string, const char *suffix){
    if(strlen(string) < strlen(suffix)){
        return false;
    }
    if(strcmp(string + strlen(string) - strlen(suffix), suffix) == 0){
        return true;
    }
    return false;
}

char *private_dtw_replace_string_once(const char *target, const char *old_element, const char *new_element) {

    const char *pos = strstr(target, old_element);

    int size_of_old_element = strlen(old_element);
    int size_of_new_element = strlen(new_element);
    // Allocate memory for the new string
    char *result = (char *)malloc(strlen(target) + size_of_new_element - size_of_old_element + 1);

    // Copy the part of the original string before the old substring
    strncpy(result, target, pos - target);

    // Copy the new substring to the result string
    strcpy(result + (pos - target), new_element);

    // Copy the rest of the original string after the old substring
    strcpy(result + (pos - target) + size_of_new_element, pos + size_of_old_element);

    return result;

    

}

char* dtw_replace_string(const char *target, const char *old_element, const char *new_element) {
    char *result = (char *)malloc(strlen(target) + 1);
    strcpy(result, target);
    char *temp = NULL;
    while (strstr(result, old_element) != NULL) {
        temp = private_dtw_replace_string_once(result, old_element, new_element);
        free(result);
        result = temp;
    }
    return result;
}

char *dtw_change_beginning_of_string(const char *target,int start_element_to_remove_size, const char *new_element) {
    int target_size = strlen(target);
    int new_element_size = strlen(new_element);
    char *result = (char *)malloc(target_size- start_element_to_remove_size + new_element_size   +2);
    strcpy(result, new_element);
    char *new_target = (char *)malloc(target_size - start_element_to_remove_size + 2);
    strcpy(new_target, target + start_element_to_remove_size);
    strcat(result, new_target);
    free(new_target);
    return result;
}


void private_dtw_add_end_bar_to_dirs_string_array(struct DtwStringArray * dirs){
    for(int i = 0; i < dirs->size; i++){
        if(!dtw_ends_with(dirs->strings[i], "/")){
             char *formated_dir =  (char*)malloc(strlen(dirs->strings[i]) + 2);
             sprintf(formated_dir,"%s/",dirs->strings[i]);
             dirs->set_value(dirs,i,formated_dir);
             free(formated_dir);
        }
    }
}

#ifdef __linux__
#define dtw_create_dir(path) mkdir(path,0777)
#elif _WIN32
#define dtw_create_dir(path) _mkdir(path)
#endif



void dtw_create_dir_recursively(const char *path){
    bool check = dtw_create_dir(path);
  
    int size_path = strlen(path);
    for(int i=0;i <  size_path;i++){
        if(path[i] == '\\'  || path[i] == '/'   && i != size_path - 1){
            
            char * current_path = (char*)malloc(i + 1);
            current_path[i] = '\0';
            strncpy(current_path,path,i);
          
            dtw_create_dir(current_path);
            free(current_path);
        }
    }


    
    dtw_create_dir(path);
}


void dtw_remove_any(const char* path) {

    if(remove(path) == 0){
        return;
    }
    
    struct DtwStringArray *files = dtw_list_files_recursively(path);
    int size = files->size;
    for(int i = 0; i < size; i++){
        remove(files->strings[i]);
    }
    files->delete_string_array(files);


    struct DtwStringArray *dirs = dtw_list_dirs_recursively(path,true);
    size = dirs->size;
    for(int i = dirs->size -1; i >=0; i--){
        remove(dirs->strings[i]);
    }
    dirs->delete_string_array(dirs);
    
}


char *dtw_load_any_content(const char * path,int *size,bool *is_binary){
    FILE *file = fopen(path,"rb");
    if(file == NULL){
        free(file);
        return NULL;
    }
    fseek(file,0,SEEK_END);
    *size = ftell(file);
    fseek(file,0,SEEK_SET);
    char *content = (char*)malloc(*size +1);
    fread(content,1,*size,file);

    *is_binary = false;
    for(int i = 0;i < *size;i++){
        if(content[i] == 0){
            *is_binary = true;
            break;
        }
    }
    if(!*is_binary){
        content[*size] = '\0';
    }

    fclose(file);
    return content;
}


char *dtw_load_string_file_content(const char * path){
    FILE *file = fopen(path,"r");
    if(file == NULL){
        return NULL;
    }
    fseek(file,0,SEEK_END);
    int size = ftell(file);
    fseek(file,0,SEEK_SET);
    char *content = (char*)malloc(size +1);
    fread(content,1,size,file);
    content[size] = '\0';
    fclose(file);
    return content;
}


char *dtw_load_binary_content(const char * path,int *size){
    FILE *file = fopen(path,"rb");
    if(file == NULL){
        return NULL;
    }
    fseek(file,0,SEEK_END);
    *size = ftell(file);
    fseek(file,0,SEEK_SET);
    char *content = (char*)malloc(*size);
    fread(content,1,*size,file);
    fclose(file);
    return content;
}


bool dtw_write_any_content(const char *path,const char *content,int size){
    //Iterate through the path and create directories if they don't exist
    
    for(int i = strlen(path)-1;i > 0;i--){
        //runs in negative mode til / or \ is found
        if(path[i] == '\\' || path[i] == '/'){
            char *dir_path =(char*)malloc(i);
            dir_path[i] = '\0';
            strncpy(dir_path,path,i);
            
            dtw_create_dir_recursively(dir_path);
            free(dir_path);
        
            break;
        }
    }

    FILE *file = fopen(path,"wb");
    if(file == NULL){
   
        return false;
    }
    
    fwrite(content, sizeof(char),size, file);
    
    fclose(file);
    return true;
}


bool dtw_write_string_file_content(const char *path,char *content){
    int size;
    if(content == NULL){
        size = 0;
    }
    else{
        size = strlen(content);
    }
    return dtw_write_any_content(path,content,size);
}

int dtw_entity_type(const char *path){
    //returns 1 for file, 2 for directory, -1 for not found
    struct stat path_stat; 

    if(stat(path,&path_stat) == 0){
        if(S_ISREG(path_stat.st_mode)){
            return DTW_FILE_TYPE;
        }else if(S_ISDIR(path_stat.st_mode)){
            return DTW_FOLDER_TYPE;
        }
    }
    return NOT_FOUND;
}

bool dtw_copy_any(const char* src_path,const  char* dest_path,bool merge) {

    //verify if is an file
    int type = dtw_entity_type(src_path);
    if(type == NOT_FOUND){
        return false;
    }

    if(type == DTW_FILE_TYPE){
    
        int size;
        bool is_binary;
        char *content = dtw_load_any_content(src_path,&size,&is_binary);
        bool result =  dtw_write_any_content(dest_path,content,size);
        free(content);
        return result;
    }
    //means is an directory

    //remove the previous directory if merge is false
    if(!merge){
        dtw_remove_any(dest_path);
    }
    //creating dirs
    struct DtwStringArray *dirs = dtw_list_dirs_recursively(src_path,true);
    
    int size = dirs->size;
    int src_path_size = strlen(src_path);

    for(int i = 0; i < size; i++){
        
        char *new_path_dir = dtw_change_beginning_of_string(dirs->strings[i],src_path_size,dest_path);
        dtw_create_dir_recursively(new_path_dir);
        free(new_path_dir);
    }
    dirs->delete_string_array(dirs);
    

    struct DtwStringArray *files = dtw_list_files_recursively(src_path);
   
    for(int i = 0; i < files->size; i++){
        int file_size;
        bool is_binary;
        char *content = dtw_load_any_content(files->strings[i],&file_size,&is_binary);
        char *new_path = dtw_change_beginning_of_string(files->strings[i],src_path_size,dest_path);

        dtw_write_any_content(new_path,content,file_size);
        free(content);
        free(new_path);

       
    }

    files->delete_string_array(files);
    
    return true;
    
}

void dtw_move_any(char* src_path, char* dest_path,bool merge) {
    dtw_copy_any(src_path,dest_path,merge);
    dtw_remove_any(src_path);
}


struct DtwStringArray * dtw_list_files(char *path, bool concat_path){
    return dtw_list_basic(path,  DTW_FILE_TYPE, concat_path, false);
}

struct DtwStringArray * dtw_list_dirs(char *path, bool concat_path, bool add_end_bar_to_dir){
    return dtw_list_basic(path,DTW_FOLDER_TYPE, concat_path, add_end_bar_to_dir);
}

struct DtwStringArray *  dtw_list_all(char *path,  bool concat_path, bool add_end_bar_to_dir){
    return dtw_list_basic(path, DTW_ALL_TYPE, concat_path, add_end_bar_to_dir);
}


#ifdef __linux__

bool private_dtw_verify_if_add(const int expected_type, int d_type){
    if (expected_type == DTW_FILE_TYPE  && d_type == DT_REG) {
        return true;
    }

    if (expected_type == DTW_FOLDER_TYPE && d_type == DT_DIR) {
        return true;
    }

    if (expected_type == DTW_ALL_TYPE) {
      
        return true;
    }
    return false;
}
bool private_dtw_verify_if_skip(struct dirent *entry){
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            return true;
        }
        return false;
}

struct DtwStringArray * dtw_list_basic(const char *path,int expected_type,bool concat_path,bool add_end_bar_to_dir){

    DIR *dir;
    struct dirent *entry;

    //array of directories
    struct DtwStringArray *dirs = dtw_constructor_string_array();
    int i = 0;

    //means that the directory is not found
    if ((dir = opendir(path)) == NULL) {
        return dirs;
    }

    //reads the directory and adds the directories to the array
    while ((entry = readdir(dir)) != NULL) {
        //means is not a directory
        if (private_dtw_verify_if_skip(entry)){
            continue;
        }
    
        if (private_dtw_verify_if_add(expected_type,entry->d_type)) {
            
            
            if(concat_path){
                //allocates memory for the directory
                char *generated_dir = (char*)malloc(strlen(path) + strlen(entry->d_name) + 2);
                sprintf(generated_dir, "%s/%s", path, entry->d_name);
                
                dirs->add_string(dirs, generated_dir);
                free(generated_dir);

            }
            else{
                dirs->add_string(dirs, entry->d_name);
                
            }

            i++;
        }
    }

    if(expected_type == DTW_FOLDER_TYPE && add_end_bar_to_dir){
        private_dtw_add_end_bar_to_dirs_string_array(dirs);
        
    }
    closedir(dir);

    return dirs;
}

#endif

#ifdef _WIN32


bool private_dtw_verify_if_add(const int expected_type, WIN32_FIND_DATAA entry){
    #define WIN32_FILETYPE 32

    if (expected_type == DTW_FILE_TYPE && entry.dwFileAttributes == WIN32_FILETYPE) {
        return true;
    }

    if (expected_type == DTW_FOLDER_TYPE && entry.dwFileAttributes != WIN32_FILETYPE){
        return true;
    }

    if (expected_type == DTW_ALL_TYPE) {
        return true;
    }
    
    return false;
}

bool private_dtw_verify_if_skip(WIN32_FIND_DATAA *entry){
    if (strcmp(entry->cFileName, ".") == 0 || strcmp(entry->cFileName, "..") == 0) {
        return true;
    }
    return false;
}

struct DtwStringArray * dtw_list_basic(const char *path,int type, bool concat_path, bool add_end_bar_to_dir){

    WIN32_FIND_DATAA file_data;
    HANDLE file_handle;
    char search_path[MAX_PATH];

    //array of directories
    struct DtwStringArray *dirs = dtw_constructor_string_array();
    int i = 0;

    // build the search path string
    snprintf(search_path, MAX_PATH, "%s\\*", path);

    // try to open the directory
    if ((file_handle = FindFirstFileA(search_path, &file_data)) == INVALID_HANDLE_VALUE) {
        return dirs;
    }

    do {
        // skip "." and ".." directories
        if (private_dtw_verify_if_skip(&file_data)){
            continue;
        }

        // verify if it's a file or directory
        if (private_dtw_verify_if_add(type, file_data)) {
            
            if(concat_path){
                // allocate memory for the directory
                char *generated_dir = (char*)malloc(strlen(path) + strlen(file_data.cFileName) + 2);
                sprintf(generated_dir, "%s\\%s", path, file_data.cFileName);
                dirs->add_string(dirs, generated_dir);
            
                free(generated_dir);
            }
            else{
                dirs->add_string(dirs, file_data.cFileName);
            
            }

            i++;
        }
    } while (FindNextFileA(file_handle, &file_data) != 0);

        if(expected_type == DTW_FOLDER_TYPE && add_end_bar_to_dir){
        for(int i = 0; i < dirs->size; i++){
            char *dir = dirs->strings[i];
            char *new_dir = (char*)malloc(strlen(dir) + 1);
            //concat '/' to the end of the directory
            sprintf(new_dir, "%s/", dir);
            free(dirs->strings[i]);
            dirs->strings[i] = new_dir;
        }
    }
    
    FindClose(file_handle);

    return dirs;
}
#endif

struct DtwStringArray * dtw_list_dirs_recursively(const char *path,bool add_end_bar_to_dir){

        struct  DtwStringArray *dirs  = dtw_constructor_string_array();
        //verify if the path is a directory
        
        DIR *dir = opendir(path);
        if( dir == NULL){
                return dirs;
        }
        closedir(dir);
        
        dirs->add_string(dirs,path);

        int i = 0;
        //The size of dirs will increase til it reaches the end of the array
        while(i < dirs->size){                
                struct DtwStringArray *sub_dirs = dtw_list_basic(
                    dirs->strings[i],
                    DTW_FOLDER_TYPE,
                    true,
                    false
                    );
                //merge the two dirs
                dirs->merge_string_array(dirs,sub_dirs);
                sub_dirs->delete_string_array(sub_dirs);
                i++;
                return dirs;
        }
        //unsifth path in dirs 
        
        
        if(add_end_bar_to_dir){
            private_dtw_add_end_bar_to_dirs_string_array(dirs);
        }

        return dirs;
}



struct DtwStringArray *  dtw_list_files_recursively(const char *path){
    
    struct DtwStringArray *dirs = dtw_list_dirs_recursively(path,false);
    
    struct  DtwStringArray *files = dtw_constructor_string_array();
    
    for(int i = 0; i < dirs->size; i++){
        struct DtwStringArray *sub_files = dtw_list_basic(dirs->strings[i],DTW_FILE_TYPE,true,false);
        files->merge_string_array(files,sub_files);
        sub_files->delete_string_array(sub_files);
    }
    dirs->delete_string_array(dirs);
    return files;
}
struct DtwStringArray * dtw_list_all_recursively(const char *path,bool add_end_bar_to_dir){

    struct DtwStringArray *dirs = dtw_list_dirs_recursively(path,false);
    
    struct DtwStringArray *all = dtw_constructor_string_array();
    
    for(int i = 0; i < dirs->size; i++){
        if(add_end_bar_to_dir){
   
            char *formated_dir =  (char*)malloc(strlen(dirs->strings[i]) + 2);
            sprintf(formated_dir,"%s/",dirs->strings[i]);
            all->add_string(all,formated_dir);
            free(formated_dir);
        }
        else{
            all->add_string(all,dirs->strings[i]);
        }

        struct DtwStringArray *sub_files = dtw_list_basic(dirs->strings[i],DTW_FILE_TYPE,true,false);
        all->merge_string_array(all,sub_files);
        sub_files->delete_string_array(sub_files);
    }
    dirs->delete_string_array(dirs);
    return all;
}


struct DtwPath * dtw_constructor_path( const char *ful_path) {
    struct DtwPath *self = (struct DtwPath *)malloc(sizeof(struct DtwPath));

    self->dir = (char *)malloc(0);
    self->name = (char *)malloc(0);
    self->extension = (char *)malloc(0);

    self->changed = private_dtw_path_changed;
    self->get_full_name =private_dtw_get_full_name;
    self->get_name = private_dtw_get_name;
    self->get_extension = private_dtw_get_extension;


    self->get_full_path = private_dtw_get_full_path;
    self->get_dir = private_dtw_get_dir;

    self->set_extension = private_dtw_set_extension;
    self->set_name = private_dtw_set_name;
    self->set_dir = private_dtw_set_dir;
    self->set_full_name = private_dtw_set_full_name;
    self->set_full_path = private_dtw_set_full_path;

    self->represent = private_dtw_represent_path;
    self->delete_path = private_dtw_destructor_path;

    self->set_full_path(self, ful_path);
    self->first_full_path = self->get_full_path(self);

    return self;
}
bool private_dtw_path_changed(struct DtwPath *self){
    if(strcmp(self->first_full_path, self->get_full_path(self)) == 0){
        return false;
    }
    return true;
}

char * private_dtw_get_full_name(struct DtwPath *self){
    char *full_name = (char *)malloc(strlen(self->name) + strlen(self->extension) +1);
    //concat the name and extension with / 
    //if the extension is empty, then the full name is just the name
    if(strcmp(self->extension, "") == 0){
        sprintf(full_name, "%s", self->name);
    }else{
        sprintf(full_name, "%s.%s", self->name, self->extension);
    }
    return full_name;
}
char * private_dtw_get_name(struct DtwPath *self){
    return self->name;
}
char * private_dtw_get_extension(struct DtwPath *self){
    return self->extension;
}


char * private_dtw_get_full_path(struct DtwPath *self){
    char *full_path = (char *)malloc(strlen(self->dir) + strlen(self->name) + strlen(self->extension) +3);
    //concat the path, name and extension with / 
    char *full_name = self->get_full_name(self);
    //if the dir is empty, then the full path is just the full name
    if(strcmp(self->dir, "") == 0){
        sprintf(full_path, "%s", full_name);
    }else{
        sprintf(full_path, "%s/%s", self->dir, full_name);
    }
    free(full_name);
    return full_path;
}

char * private_dtw_get_dir(struct DtwPath *self){
    return self->dir;
}


void private_dtw_set_extension(struct DtwPath *self, const char *extension){
    if(strcmp(extension, "") == 0){
        return;
    }
    self->extension = (char *)realloc(self->extension, strlen(extension));
    strcpy(self->extension, extension);
}


void private_dtw_set_name(struct DtwPath * self, const char * name){
    if(strcmp(name, "") == 0){
        return;
    }
    self->name = (char *)realloc(self->name, strlen(name));
    strcpy(self->name, name);
}

void private_dtw_set_dir(struct DtwPath *self, const char *path){
    if(strcmp(path, "") == 0){
        return;
    }
    self->dir = (char *)realloc(self->dir, strlen(path));
    strcpy(self->dir, path);
}

void private_dtw_set_full_name(struct DtwPath * self, const char * full_name){
    
    for(int i = 0; i < strlen(full_name); i++){
        if(full_name[i] == '.'){
            char *name = (char *)malloc(i);
            //substr the name from the start to the current position
            strncpy(name, full_name, i);
            self->set_name(self, name);
            free(name);
            //substr the extension from the current position to the end
            char *extension = (char *)malloc(strlen(full_name) - i);
            strcpy(extension, full_name + i + 1);
            self->set_extension(self, extension);
            free(extension);
            return;
        }
    }
    self->set_name(self, full_name);
    
}
void private_dtw_set_full_path(struct DtwPath *self, const char *ful_path) {

    
    int full_path_size = strlen(ful_path);
    //lopos in n
    for(int i = full_path_size ;i >0; i--){
   
        if(ful_path[i] == '/' || ful_path[i] == '\\'){
            
            char *path = (char *)malloc(i);
            //substr the path from the start to the current position
            strncpy(path, ful_path, i);
            self->set_dir(self, path);
            free(path);


            //substr the name from the current position to the end
            char *name = (char *)malloc(full_path_size - i);
            strcpy(name, ful_path + i + 1);
            self->set_full_name(self, name);
            free(name);
            return;
        }
    }
    self->set_full_name(self, ful_path);

}


void private_dtw_represent_path(struct DtwPath *self){
    printf("Full Path: %s\n", self->get_full_path(self));
    printf("Changed: %s\n", self->changed(self) ? "true" : "false");
    printf("Dir: %s\n", self->get_dir(self));
    printf("Full Name: %s\n", self->get_full_name(self));
    printf("Name: %s\n", self->get_name(self));
    printf("Extension: %s\n", self->get_extension(self));
}



void private_dtw_destructor_path(struct DtwPath *self) {
    free(self->first_full_path);
    free(self->dir);
    free(self->name);
    free(self->extension);
    free(self);
}


struct DtwStringArray * dtw_constructor_string_array(){
    struct DtwStringArray *self = (struct DtwStringArray*)malloc(sizeof(struct DtwStringArray));
    self->size = 0;

    self->strings = (char**)malloc(1);
    self->add_string = private_dtw_add_string;
    self->set_value = private_dtw_set_value;
    self->merge_string_array = private_dtw_merge_string_array;
    self->represent= private_dtw_represent_string_array;
    self->delete_string_array = private_dtw_delete_string_array;
    return self;
}

void private_dtw_set_value(struct DtwStringArray *self,int index,const char *value){
    if(index < self->size && index >= 0){
        int size = strlen(value);
        self->strings[index] = (char*)realloc(self->strings[index], size + 1);
        self->strings[index][size] = '\0';
        strcpy(self->strings[index], value);
    }
}
// Function prototypes
void private_dtw_add_string(struct DtwStringArray *self,const char *string){
    self->size++;
    self->strings =  (char**)realloc(self->strings, self->size * sizeof(char *));
    self->strings[self->size - 1] = (char*)malloc(strlen(string) + 1);
    strcpy(self->strings[self->size - 1], string);
}


void private_dtw_merge_string_array(struct DtwStringArray *self, struct DtwStringArray *other){
    for(int i = 0; i < other->size; i++){
        self->add_string(self, other->strings[i]);
    }
}


void private_dtw_represent_string_array(struct DtwStringArray *self){
    for(int i = 0; i < self->size; i++){
        printf("%s\n", self->strings[i]);
    }
}
void private_dtw_delete_string_array(struct DtwStringArray *self){
    for(int i = 0; i < self->size; i++){
        free(self->strings[i]);
    }
    free(self->strings);
    free(self);
}



struct DtwTreePart * dtw_tree_part_constructor(const char *full_path,bool load_content){
    struct DtwTreePart *self = (struct DtwTreePart *)malloc(sizeof(struct DtwTreePart));
    self->path = dtw_constructor_path(full_path);
    self->content_exist_in_memory = false;
    self->content_exist_in_hardware = false;
    self->is_binary = false;
    self->ignore = false;
    self->hawdware_content_sha = (char *)malloc(0);
    self->content = (char *)malloc(0);
    self->content_size = 0;
    self->load_content_from_hardware = private_dtw_load_content_from_hardware;
    self->set_any_content = private_dtw_set_any_content;
    self->set_string_content = private_dtw_set_string_content;
    self->set_binary_content = private_dtw_set_binary_content;
    self->get_content_sha = private_dtw_get_content_sha;
    self->last_modification_time_in_string = private_dtw_last_modification_time_in_string;
    self->free_content = private_dtw_free_content;
    self->represent = private_dtw_represent_tree_part;
    self->hardware_remove = private_dtw_hardware_remove;
    self->hardware_write = private_dtw_hardware_write;
    self->delete_tree_part = private_dtw_tree_part_destructor;
    self->copy_tree_part = private_dtw_copy_tree;
    if(load_content){
        self->load_content_from_hardware(self);
    }
    return self;
}

struct  DtwTreePart * private_dtw_copy_tree(struct DtwTreePart *self){
    char *full_path = self->path->get_full_path(self->path);

    struct DtwTreePart *new_tree_part = dtw_tree_part_constructor(full_path,false);
    free(full_path);

    new_tree_part->content_exist_in_memory = self->content_exist_in_memory;
    new_tree_part->content_exist_in_hardware = self->content_exist_in_hardware;
    new_tree_part->is_binary = self->is_binary;
    new_tree_part->ignore = self->ignore;
    new_tree_part->content_size = self->content_size;
    

    new_tree_part->hawdware_content_sha = (char *)malloc(strlen(self->hawdware_content_sha)+1);
    strcpy(new_tree_part->hawdware_content_sha,self->hawdware_content_sha);
    new_tree_part->content = (char *)malloc(self->content_size);
    memcpy(new_tree_part->content,self->content,self->content_size);

    
    return new_tree_part;
}


void private_dtw_set_any_content(struct DtwTreePart *self,const char *content,int content_size,bool is_binary,bool set_last_modification_time){
    self->free_content(self);
    self->content_exist_in_memory = true;
    self->is_binary = is_binary;
    self->content = (char *)realloc(self->content,content_size);
    memcpy(self->content,content,content_size);
    self->content_size = content_size;

    if(set_last_modification_time){
        self->last_modification_time = time(NULL);
    }
}

void private_dtw_set_string_content(struct DtwTreePart *self,const char *content){
    self->set_any_content(self,content,strlen(content),false,true);
    self->content[self->content_size] = '\0';
}
void private_dtw_set_binary_content(struct DtwTreePart *self,const char *content,int content_size){
    self->set_any_content(self,content,content_size,true,true);
}

void private_dtw_load_content_from_hardware(struct DtwTreePart *self){
    int size;
    bool is_binary;
    char *full_path = self->path->get_full_path(self->path);
    if(dtw_entity_type(full_path) != DTW_FILE_TYPE){
        free(full_path);
        return;
    }
    self->content = dtw_load_any_content(full_path,&size,&is_binary);
    self->content_exist_in_memory = true;
    self->is_binary = is_binary;
    self->content_size = size;
    self->last_modification_time = dtw_get_file_last_motification_in_unix(full_path);
    self->content_exist_in_hardware = true;
    free(self->hawdware_content_sha);
    self->hawdware_content_sha = dtw_generate_sha_from_string(self->content);
    free(full_path);
    
}
char *private_dtw_get_content_sha(struct DtwTreePart *self){
    if(self->content_exist_in_memory){
        return dtw_generate_sha_from_string(self->content);
    }
    return NULL;
}

char *private_dtw_last_modification_time_in_string(struct DtwTreePart *self){
    return dtw_convert_unix_time_to_string(self->last_modification_time);
}



void private_dtw_represent_tree_part(struct DtwTreePart *self){
    char *full_path = self->path->get_full_path(self->path);
    printf("------------------------------------------------------------\n");
    printf("Path: %s\n",full_path);
    printf("Content Exist in Memory: %s\n",self->content_exist_in_memory ? "true" : "false");
    if(self->content_exist_in_memory == true || self->content_exist_in_hardware == true){
        
        char *last_moditication_in_string = self->last_modification_time_in_string(self);

        printf("Content Exist In Hardware: %s\n",self->content_exist_in_hardware ? "true" : "false");
        printf("Is Binary: %s\n",self->is_binary ? "true" : "false");
        printf("Last Modification Time in Unix: %li\n",self->last_modification_time);
        printf("Last Modification Time: %s\n",last_moditication_in_string);
        printf("Content Size: %d\n",self->content_size);
        printf("Hardware SHA: %s\n",self->hawdware_content_sha);    
        if(self->content_exist_in_memory == true){
            char *content_sha = self->get_content_sha(self);
            printf("Content SHA:  %s\n",content_sha);
            printf ("Content: %s\n",self->content);
            free(content_sha);
        }
        
        free(last_moditication_in_string);
    }
    free(full_path);

}

bool private_dtw_hardware_remove(struct DtwTreePart *self){
     if(self->ignore == true){
        return false;
     }
    char *full_path = self->path->get_full_path(self->path);
    dtw_remove_any(full_path);
    free(full_path);
    return true;
}
bool private_dtw_hardware_write(struct DtwTreePart *self){
    if(self->ignore == true){
        return false;
    }
    //means that the content not exist in memory
    if(self->content_exist_in_memory == false){
        char *full_path = self->path->get_full_path(self->path);
        char *name = self->path->get_full_name(self->path);
        if(strcmp(name,"") == 0){
            dtw_create_dir_recursively(full_path);
          
        }
        else{
            dtw_write_string_file_content(full_path,NULL);
        }
        free(full_path);
        free(name);
        return true;
    }
    char *full_path = self->path->get_full_path(self->path);

    dtw_write_any_content(full_path,self->content,self->content_size);
    free(full_path);
    return true;
  
}



void private_dtw_free_content(struct DtwTreePart *self){
    self->content_exist_in_memory = false;
    self->content = (char *)realloc(self->content,0);
}
void private_dtw_tree_part_destructor(struct DtwTreePart *self){
    self->path->delete_path(self->path);
    free(self->hawdware_content_sha);
    free(self->content);
    free(self);
}



struct  DtwTree * dtw_tree_constructor(){
    struct DtwTree *self = (struct DtwTree*)malloc(sizeof(struct DtwTree));
    self->size = 0;
    self->tree_parts = (struct DtwTreePart**)malloc(1);
    self->add_tree_part_by_copy = private_dtw_add_tree_part_copy;
    self->add_tree_part_by_referene = private_dtw_add_tree_part_reference;
    self->delete_tree = private_dtw_delete_tree;
    self->represent = private_dtw_represent_tree;
    return self;
}

void private_dtw_add_tree_part_copy(struct DtwTree *self, struct DtwTreePart *tree_part){
    self->size++;
    self->tree_parts =  (struct DtwTreePart**)realloc(self->tree_parts, self->size * sizeof(struct DtwTreePart *));
    self->tree_parts[self->size - 1] = tree_part->copy_tree_part(tree_part);
       
}
void private_dtw_add_tree_part_reference(struct DtwTree *self, struct DtwTreePart *tree_part){
    self->size++;
    self->tree_parts =  (struct DtwTreePart**)realloc(self->tree_parts, self->size * sizeof(struct DtwTreePart *));
    self->tree_parts[self->size - 1] = tree_part;
}


void private_dtw_delete_tree(struct DtwTree *self){
    for(int i = 0; i < self->size; i++){
        self->tree_parts[i]->delete_tree_part(self->tree_parts[i]);
    }
    free(self);
}

void private_dtw_represent_tree(struct DtwTree *self){
    for(int i = 0; i < self->size; i++){
        self->tree_parts[i]->represent(self->tree_parts[i]);
    }
}